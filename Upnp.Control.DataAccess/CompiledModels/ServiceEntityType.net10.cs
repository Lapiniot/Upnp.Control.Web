// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Upnp.Control.Models;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Upnp.Control.DataAccess.CompiledModels
{
    [EntityFrameworkInternal]
    public partial class ServiceEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Upnp.Control.Models.Service",
                typeof(Service),
                baseEntityType,
                propertyCount: 7,
                foreignKeyCount: 1,
                unnamedIndexCount: 1,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(int),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0);
            id.SetAccessors(
                int (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : (entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0))),
                int (IInternalEntry entry) => entry.ReadShadowValue<int>(0),
                int (IInternalEntry entry) => entry.ReadOriginalValue<int>(id, 0),
                int (IInternalEntry entry) => ((InternalEntityEntry)entry).ReadRelationshipSnapshotValue<int>(id, 0));
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: 0,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            id.TypeMapping = IntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                keyComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                providerValueComparer: new ValueComparer<int>(
                    bool (int v1, int v2) => v1 == v2,
                    int (int v) => v,
                    int (int v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(id));

            var controlUrl = runtimeEntityType.AddProperty(
                "ControlUrl",
                typeof(Uri),
                propertyInfo: typeof(Service).GetProperty("ControlUrl", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Service).GetField("<ControlUrl>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            controlUrl.SetGetter(
                Uri (Service instance) => ServiceUnsafeAccessors.ControlUrl(instance),
                bool (Service instance) => ServiceUnsafeAccessors.ControlUrl(instance) == null);
            controlUrl.SetSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.ControlUrl(instance) = value;
                    return instance;
                });
            controlUrl.SetMaterializationSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.ControlUrl(instance) = value;
                    return instance;
                });
            controlUrl.SetAccessors(
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.ControlUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.ControlUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(controlUrl, 1),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(controlUrl));
            controlUrl.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            controlUrl.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var eventsUrl = runtimeEntityType.AddProperty(
                "EventsUrl",
                typeof(Uri),
                propertyInfo: typeof(Service).GetProperty("EventsUrl", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Service).GetField("<EventsUrl>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            eventsUrl.SetGetter(
                Uri (Service instance) => ServiceUnsafeAccessors.EventsUrl(instance),
                bool (Service instance) => ServiceUnsafeAccessors.EventsUrl(instance) == null);
            eventsUrl.SetSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.EventsUrl(instance) = value;
                    return instance;
                });
            eventsUrl.SetMaterializationSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.EventsUrl(instance) = value;
                    return instance;
                });
            eventsUrl.SetAccessors(
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.EventsUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.EventsUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(eventsUrl, 2),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(eventsUrl));
            eventsUrl.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            eventsUrl.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var metadataUrl = runtimeEntityType.AddProperty(
                "MetadataUrl",
                typeof(Uri),
                propertyInfo: typeof(Service).GetProperty("MetadataUrl", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Service).GetField("<MetadataUrl>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            metadataUrl.SetGetter(
                Uri (Service instance) => ServiceUnsafeAccessors.MetadataUrl(instance),
                bool (Service instance) => ServiceUnsafeAccessors.MetadataUrl(instance) == null);
            metadataUrl.SetSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.MetadataUrl(instance) = value;
                    return instance;
                });
            metadataUrl.SetMaterializationSetter(
                Service (Service instance, Uri value) =>
                {
                    ServiceUnsafeAccessors.MetadataUrl(instance) = value;
                    return instance;
                });
            metadataUrl.SetAccessors(
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.MetadataUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => ServiceUnsafeAccessors.MetadataUrl(((Service)(entry.Entity))),
                Uri (IInternalEntry entry) => entry.ReadOriginalValue<Uri>(metadataUrl, 3),
                Uri (IInternalEntry entry) => entry.GetCurrentValue<Uri>(metadataUrl));
            metadataUrl.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            metadataUrl.TypeMapping = SqliteStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                keyComparer: new ValueComparer<Uri>(
                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
                    int (Uri v) => ((object)v).GetHashCode(),
                    Uri (Uri v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                converter: new ValueConverter<Uri, string>(
                    string (Uri v) => ((object)v).ToString(),
                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<Uri, string>(
                        string (Uri v) => ((object)v).ToString(),
                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));

            var serviceType = runtimeEntityType.AddProperty(
                "ServiceType",
                typeof(string),
                propertyInfo: typeof(Service).GetProperty("ServiceType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Service).GetField("<ServiceType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            serviceType.SetGetter(
                string (Service instance) => ServiceUnsafeAccessors.ServiceType(instance),
                bool (Service instance) => ServiceUnsafeAccessors.ServiceType(instance) == null);
            serviceType.SetSetter(
                Service (Service instance, string value) =>
                {
                    ServiceUnsafeAccessors.ServiceType(instance) = value;
                    return instance;
                });
            serviceType.SetMaterializationSetter(
                Service (Service instance, string value) =>
                {
                    ServiceUnsafeAccessors.ServiceType(instance) = value;
                    return instance;
                });
            serviceType.SetAccessors(
                string (IInternalEntry entry) => ServiceUnsafeAccessors.ServiceType(((Service)(entry.Entity))),
                string (IInternalEntry entry) => ServiceUnsafeAccessors.ServiceType(((Service)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(serviceType, 4),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(serviceType));
            serviceType.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            serviceType.TypeMapping = SqliteStringTypeMapping.Default;

            var udn = runtimeEntityType.AddProperty(
                "Udn",
                typeof(string));
            udn.SetAccessors(
                string (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(5) ? entry.ReadStoreGeneratedValue<string>(1) : (entry.FlaggedAsTemporary(5) && entry.ReadShadowValue<string>(1) == null ? entry.ReadTemporaryValue<string>(1) : entry.ReadShadowValue<string>(1))),
                string (IInternalEntry entry) => entry.ReadShadowValue<string>(1),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(udn, 5),
                string (IInternalEntry entry) => ((InternalEntityEntry)entry).ReadRelationshipSnapshotValue<string>(udn, 1));
            udn.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: 1,
                relationshipIndex: 1,
                storeGenerationIndex: 1);
            udn.TypeMapping = SqliteStringTypeMapping.Default;
            udn.SetCurrentValueComparer(new EntryCurrentValueComparer<string>(udn));

            var uniqueServiceName = runtimeEntityType.AddProperty(
                "UniqueServiceName",
                typeof(string),
                propertyInfo: typeof(Service).GetProperty("UniqueServiceName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Service).GetField("<UniqueServiceName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            uniqueServiceName.SetGetter(
                string (Service instance) => ServiceUnsafeAccessors.UniqueServiceName(instance),
                bool (Service instance) => ServiceUnsafeAccessors.UniqueServiceName(instance) == null);
            uniqueServiceName.SetSetter(
                Service (Service instance, string value) =>
                {
                    ServiceUnsafeAccessors.UniqueServiceName(instance) = value;
                    return instance;
                });
            uniqueServiceName.SetMaterializationSetter(
                Service (Service instance, string value) =>
                {
                    ServiceUnsafeAccessors.UniqueServiceName(instance) = value;
                    return instance;
                });
            uniqueServiceName.SetAccessors(
                string (IInternalEntry entry) => ServiceUnsafeAccessors.UniqueServiceName(((Service)(entry.Entity))),
                string (IInternalEntry entry) => ServiceUnsafeAccessors.UniqueServiceName(((Service)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(uniqueServiceName, 6),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(uniqueServiceName));
            uniqueServiceName.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            uniqueServiceName.TypeMapping = SqliteStringTypeMapping.Default;

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { udn });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("Udn") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Udn") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true,
                ownership: true);

            var services = principalEntityType.AddNavigation("Services",
                runtimeForeignKey,
                onDependent: false,
                typeof(IEnumerable<Service>),
                propertyInfo: typeof(UpnpDevice).GetProperty("Services", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(UpnpDevice).GetField("<Services>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                eagerLoaded: true);

            services.SetGetter(
                IEnumerable<Service> (UpnpDevice instance) => UpnpDeviceUnsafeAccessors.Services(instance),
                bool (UpnpDevice instance) => UpnpDeviceUnsafeAccessors.Services(instance) == null);
            services.SetSetter(
                UpnpDevice (UpnpDevice instance, IEnumerable<Service> value) =>
                {
                    UpnpDeviceUnsafeAccessors.Services(instance) = value;
                    return instance;
                });
            services.SetMaterializationSetter(
                UpnpDevice (UpnpDevice instance, IEnumerable<Service> value) =>
                {
                    UpnpDeviceUnsafeAccessors.Services(instance) = value;
                    return instance;
                });
            services.SetAccessors(
                IEnumerable<Service> (IInternalEntry entry) => UpnpDeviceUnsafeAccessors.Services(((UpnpDevice)(entry.Entity))),
                IEnumerable<Service> (IInternalEntry entry) => UpnpDeviceUnsafeAccessors.Services(((UpnpDevice)(entry.Entity))),
                null,
                IEnumerable<Service> (IInternalEntry entry) => entry.GetCurrentValue<IEnumerable<Service>>(services));
            services.SetPropertyIndexes(
                index: 1,
                originalValueIndex: -1,
                shadowIndex: -1,
                relationshipIndex: 2,
                storeGenerationIndex: -1);
            services.SetCollectionAccessor<UpnpDevice, IEnumerable<Service>, Service>(
                IEnumerable<Service> (UpnpDevice entity) => UpnpDeviceUnsafeAccessors.Services(entity),
                (UpnpDevice entity, IEnumerable<Service> collection) => UpnpDeviceUnsafeAccessors.Services(entity) = ((IEnumerable<Service>)collection),
                (UpnpDevice entity, IEnumerable<Service> collection) => UpnpDeviceUnsafeAccessors.Services(entity) = ((IEnumerable<Service>)collection),
                IEnumerable<Service> (UpnpDevice entity, Action<UpnpDevice, IEnumerable<Service>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<UpnpDevice, IEnumerable<Service>, Service>(entity, setter),
                IEnumerable<Service> () => ((IEnumerable<Service>)(((ICollection<Service>)(new HashSet<Service>(ReferenceEqualityComparer.Instance))))));
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var id = runtimeEntityType.FindProperty("Id");
            var controlUrl = runtimeEntityType.FindProperty("ControlUrl");
            var eventsUrl = runtimeEntityType.FindProperty("EventsUrl");
            var metadataUrl = runtimeEntityType.FindProperty("MetadataUrl");
            var serviceType = runtimeEntityType.FindProperty("ServiceType");
            var udn = runtimeEntityType.FindProperty("Udn");
            var uniqueServiceName = runtimeEntityType.FindProperty("UniqueServiceName");
            var key = runtimeEntityType.FindKey(new[] { id });
            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((Service)(source.Entity));
                    return ((ISnapshot)(new Snapshot<int, Uri, Uri, Uri, string, string, string>(((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(id)), (source.GetCurrentValue<Uri>(controlUrl) == null ? null : ((ValueComparer<Uri>)(((IProperty)controlUrl).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(controlUrl))), (source.GetCurrentValue<Uri>(eventsUrl) == null ? null : ((ValueComparer<Uri>)(((IProperty)eventsUrl).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(eventsUrl))), (source.GetCurrentValue<Uri>(metadataUrl) == null ? null : ((ValueComparer<Uri>)(((IProperty)metadataUrl).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(metadataUrl))), (source.GetCurrentValue<string>(serviceType) == null ? null : ((ValueComparer<string>)(((IProperty)serviceType).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(serviceType))), (source.GetCurrentValue<string>(udn) == null ? null : ((ValueComparer<string>)(((IProperty)udn).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(udn))), (source.GetCurrentValue<string>(uniqueServiceName) == null ? null : ((ValueComparer<string>)(((IProperty)uniqueServiceName).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(uniqueServiceName))))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<int, string>(((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(default(int)), (default(string) == null ? null : ((ValueComparer<string>)(((IProperty)udn).GetValueComparer())).Snapshot(default(string)))))));
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (IInternalEntry source) => ((ISnapshot)(new Snapshot<int, string>(default(int), default(string)))));
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<int, string>((source.ContainsKey("Id") ? ((int)(source["Id"])) : 0), (source.ContainsKey("Udn") ? ((string)(source["Udn"])) : null)))));
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => ((ISnapshot)(new Snapshot<int, string>(default(int), default(string)))));
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((Service)(source.Entity));
                    return ((ISnapshot)(new Snapshot<int, string>(((ValueComparer<int>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<int>(id)), (source.GetCurrentValue<string>(udn) == null ? null : ((ValueComparer<string>)(((IProperty)udn).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<string>(udn))))));
                });
            runtimeEntityType.SetCounts(new PropertyCounts(
                propertyCount: 7,
                navigationCount: 0,
                complexPropertyCount: 0,
                complexCollectionCount: 0,
                originalValueCount: 7,
                shadowCount: 2,
                relationshipCount: 2,
                storeGeneratedCount: 2));
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Service");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}